#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

// --- SETTINGS ---
// Clamps max brightness to prevent "Blue Noise" fireflies from getting stuck
const float CLAMP_MAX = 5.0; 

void main()
{
    uint index = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    // Jitter seed per frame
    uint seed = index + ubo.frameCount * 719393; 
    
    // 1. Antialiasing Jitter
    float rX = rnd(seed);
    float rY = rnd(seed);
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(rX, rY);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    // 2. Camera Ray
    vec4 origin = inverse(ubo.view) * vec4(0, 0, 0, 1);
    vec4 target = inverse(ubo.proj) * vec4(d.x, d.y, 1, 1);
    vec4 direction = inverse(ubo.view) * vec4(normalize(target.xyz / target.w), 0);
    vec3 ray_origin = origin.xyz;
    vec3 ray_dir = normalize(direction.xyz);

    // 3. Trace Path
    vec3 accumulated_color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    payload.seed = seed;

    for (int depth = 0; depth < 8; depth++) { 
        traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, ray_origin, 0.001, ray_dir, 10000.0, 0);
        accumulated_color += payload.color * throughput;

        if (payload.hit_flag < 1.5) break; 

        throughput *= payload.weight;
        ray_origin = payload.next_ray_origin;
        ray_dir = payload.next_ray_dir;
        
        // Russian Roulette
        if(depth >= 4) {
            float p = max(max(throughput.r, throughput.g), throughput.b);
            if (rnd(payload.seed) > p) break;
            throughput /= p;
        }
    }
    
    // 4. FIREFLY CLAMP (Fixes the "Blue Noise")
    // Before accumulating, clamp super-bright pixels.
    // This allows us to use Gamma accumulation without the noise sticking.
    accumulated_color = min(accumulated_color, vec3(CLAMP_MAX));

    // 5. ACCUMULATION (GAMMA SPACE WORKAROUND)
    // We convert to Gamma *before* mixing. This preserves the dark Blue channel
    // in your 8-bit buffer, preventing the "Yellow" death.
    vec3 current_gamma = pow(accumulated_color, vec3(1.0 / 2.2));

    if (ubo.frameCount > 0) {
        // Load previous frame (already in Gamma space)
        vec3 prev_gamma = imageLoad(rt_output_image, ivec2(gl_LaunchIDEXT.xy)).rgb;
        
        // Standard Moving Average
        float blend = 1.0 / float(ubo.frameCount + 1);
        
        // 8-BIT PRECISION GUARD:
        // Don't let blend factor drop below 1/255, or updates will stop/quantize.
        // blend = max(blend, 0.005); 
        
        current_gamma = mix(prev_gamma, current_gamma, blend);
    }

    imageStore(rt_output_image, ivec2(gl_LaunchIDEXT.xy), vec4(current_gamma, 1.0));
}
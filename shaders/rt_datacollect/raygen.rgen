#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"


// Binding 1: Ray Samples
layout(set = 0, binding = 1, scalar) buffer readonly SampleBuffer {
    RaySample samples[];
} sample_buffer;

// Binding 2: Output Hit Buffer
layout(set = 0, binding = 2, scalar) buffer writeonly OutputHitBuffer {
    HitData hits[];
} output_buffer;

layout(push_constant) uniform PushConstants {
    mat4 model;
    float major_radius;
    float minor_radius;
    float height;
} pc;

layout(location = 0) rayPayloadEXT RayPayload payload;

const float PI = 3.14159265359;

void main()
{
    uint index = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    if (index >= sample_buffer.samples.length()) return;

    // ... [Same Torus Geometry Reconstruction Logic as before] ...
    vec2 uv = sample_buffer.samples[index].uv;
    float u = uv.x * 2.0 * PI;
    float v = uv.y * 2.0 * PI;
    float R = pc.major_radius;
    float r = pc.minor_radius;
    float h = pc.height;
    
    vec3 local_pos;
    local_pos.x = (R + r * cos(v)) * cos(u);
    local_pos.y = r * sin(v) + h;
    local_pos.z = (R + r * cos(v)) * sin(u);
    
    vec3 local_normal;
    local_normal.x = cos(v) * cos(u);
    local_normal.y = sin(v);
    local_normal.z = cos(v) * sin(u);
    local_normal = normalize(local_normal);
    
    vec3 ray_origin = (pc.model * vec4(local_pos, 1.0)).xyz;
    vec3 ray_dir = normalize((pc.model * vec4(local_normal, 0.0)).xyz);

    // Init Payload
    payload.depth = 0;
    payload.hit_flag = 0.0;

    // Trace
    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, ray_origin, 0.001, ray_dir, 10000.0, 0);

    // WRITE RESULT TO BUFFER
    output_buffer.hits[index].hit_pos = payload.hit_pos;
    output_buffer.hits[index].hit_flag = payload.hit_flag;
    output_buffer.hits[index].color = vec4(payload.color, 1.0);
    output_buffer.hits[index].normal = payload.normal;
    output_buffer.hits[index].padding = 0.0;
}
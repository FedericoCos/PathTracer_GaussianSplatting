#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"

// We use the same payload as the torus capture to reuse the Closest Hit logic
layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    // --- 1. Calculate Ray Origin and Direction ---
    // Ideally, pass inverse matrices in UBO to avoid per-pixel inversion. 
    // For now, we calculate it here for simplicity.
    
    vec4 origin = inverse(ubo.view) * vec4(0, 0, 0, 1);
    vec4 target = inverse(ubo.proj) * vec4(d.x, d.y, 1, 1);
    vec4 direction = inverse(ubo.view) * vec4(normalize(target.xyz / target.w), 0);

    vec3 ray_origin = origin.xyz;
    vec3 ray_dir = normalize(direction.xyz);

    // --- 2. Initialize Payload ---
    payload.depth = 0;
    payload.hit_flag = 0.0;
    payload.color = vec3(0.0);

    // --- 3. Trace Ray ---
    // tmin = 0.001 to avoid self-intersection acne
    // tmax = 10000.0 (Far plane)
    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, ray_origin, 0.001, ray_dir, 10000.0, 0);

    // --- 4. Write to Image ---
    // If we missed, payload.color is set by the Miss shader (e.g., Sky color)
    
    // We can apply simple gamma correction here since we are writing to an image for display
    vec3 finalColor = pow(payload.color, vec3(1.0 / 2.2));
    
    imageStore(rt_output_image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0));
}
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"

layout(set = 0, binding = 1, scalar) buffer readonly SampleBuffer { RaySample samples[]; } sample_buffer;
layout(set = 0, binding = 2, scalar) buffer HitDataBuffer { HitData hits[]; } hit_buffer;

layout(location = 0) rayPayloadEXT RayPayload payload;

layout(push_constant) uniform PushConstants {
    mat4 model;
    int mode; 
    float major_radius;
    float minor_radius;
    float height;
} pc;

vec2 r2_sequence(uint i) {
    const float a1 = 0.75487766624669276; 
    const float a2 = 0.56984029099805327;
    return vec2(float(i) * a1, float(i) * a2);
}

const float PI = 3.14159265359;
// MATCH CAMERA RENDERER CLAMP
const float CLAMP_MAX = 5.0; 

void main()
{
    uint index = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;

    if (index >= sample_buffer.samples.length()) return;

    // Seeds
    uint geo_seed = index; 
    uint light_seed = index + ubo.frameCount * 719393;

    // --- 1. GEOMETRY (FIXED DISTORTION) ---
    // Removed V-Flip to match C++ Torus::generateMesh exactly
    vec2 uv = sample_buffer.samples[index].uv;
    float u = uv.x * 2.0 * PI;
    float v = uv.y * 2.0 * PI; 

    float R = pc.major_radius;
    float r = pc.minor_radius;
    float h = pc.height;

    // Parametric Torus (Standard Math)
    vec3 local_pos;
    local_pos.x = (R + r * cos(v)) * cos(u);
    local_pos.y = r * sin(v) + h; 
    local_pos.z = (R + r * cos(v)) * sin(u);

    vec3 local_norm;
    local_norm.x = cos(v) * cos(u);
    local_norm.y = sin(v);
    local_norm.z = cos(v) * sin(u);
    
    vec3 world_origin = (pc.model * vec4(local_pos, 1.0)).xyz;
    vec3 world_norm = normalize((pc.model * vec4(local_norm, 0.0)).xyz);
    
    // Shoot Outwards
    vec3 ray_dir = world_norm; 
    vec3 safe_origin = world_origin + (ray_dir * 0.05); 

    // --- 2. TRACE ---
    ivec2 size = textureSize(blueNoiseTex, 0);
    // Offset read position by frame count to "spin" the noise pattern
    vec2 random_offset = fract(r2_sequence(ubo.frameCount)); 
    ivec2 pixel_offset = ivec2(random_offset * vec2(size));

    // Apply Toroidal Shift
    ivec2 pos = (ivec2(gl_LaunchIDEXT.xy) + pixel_offset) & (size - 1);
    vec4 blue = texelFetch(blueNoiseTex, pos, 0);

    vec3 accumulated_color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    payload.seed = light_seed;
    payload.last_bsdf_pdf = 0.0;
    payload.blue_noise = blue.ba;
    payload.depth = 0;

    traceRayEXT(tlas, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, safe_origin, 0.0, ray_dir, 10000.0, 0);

    vec3 final_hit_pos = payload.hit_pos;
    float final_hit_flag = payload.hit_flag;
    vec3 final_normal = payload.normal;

    if (payload.hit_flag > 0.5) {
        accumulated_color += payload.color * throughput;
        for (int depth = 1; depth < 12; depth++) { 
            payload.depth = depth;
             throughput *= payload.weight;
             float max_throughput = max(max(throughput.r, throughput.g), throughput.b);
            if (max_throughput < 0.001) break;
             if(depth >= 4) {
                // Calculate survival probability based on material brightness
                float p = clamp(max_throughput, 0.05, 0.95);
            
                if (rnd(payload.seed) > p) break;
                
                // Boost the survivor so the average brightness remains correct
                throughput /= p;
            }
             traceRayEXT(tlas, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, payload.next_ray_origin, 0.001, payload.next_ray_dir, 10000.0, 0);
             accumulated_color += payload.color * throughput;
            
            accumulated_color = min(accumulated_color, vec3(CLAMP_MAX)); 
             if (payload.hit_flag < 1.5) break;
        }
    }

    // --- 3. ACCUMULATION (MATCHING CAMERA LOGIC) ---
    
    // A. Clamp Fireflies (Linear)
    vec3 current_linear = accumulated_color;

    if (ubo.frameCount > 0) {
        // Read previous color (It is now Linear)
        vec3 prev_linear = hit_buffer.hits[index].color.rgb;

        float blend_factor = 1.0 / float(ubo.frameCount + 1);
        current_linear = mix(prev_linear, current_linear, blend_factor);
    }
    
    // B. Store Final LINEAR Color
    hit_buffer.hits[index].hit_pos = final_hit_pos;
    hit_buffer.hits[index].hit_flag = final_hit_flag;
    hit_buffer.hits[index].normal = final_normal;
    // Store as Linear. The Fragment Shader or Swapchain will handle Gamma.
    hit_buffer.hits[index].color = vec4(current_linear, 1.0);
}
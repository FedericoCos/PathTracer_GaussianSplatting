#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

// --- SETTINGS ---
// Clamps max brightness to prevent "Blue Noise" fireflies from getting stuck
const float CLAMP_MAX = 5.0; 

vec2 hammersley(uint i) {
    return vec2(
        float(i) * 0.61803398875, // Golden Ratio X
        float(i) * 1.32471795724  // Plastic Constant Y (or just use random seed)
    );
}

vec2 r2_sequence(uint i) {
    const float a1 = 0.75487766624669276; 
    const float a2 = 0.56984029099805327;
    return vec2(float(i) * a1, float(i) * a2);
}

void main()
{
    ivec2 size = textureSize(blueNoiseTex, 0);
    // Offset read position by frame count to "spin" the noise pattern
    vec2 random_offset = fract(r2_sequence(ubo.frameCount)); 
    ivec2 pixel_offset = ivec2(random_offset * vec2(size));

    // Apply Toroidal Shift
    ivec2 pos = (ivec2(gl_LaunchIDEXT.xy) + pixel_offset) & (size - 1);
    vec4 blue = texelFetch(blueNoiseTex, pos, 0);

    // Use blue.r and blue.g for your sub-pixel jitter
    vec2 subPixelJitter = blue.rg;
    uint index = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    // Jitter seed per frame
    uint seed = index + ubo.frameCount * 719393; 
    
    // 1. Antialiasing Jitter
    // vec2 subPixelJitter = fract(hammersley(ubo.frameCount) + vec2(rnd(seed), rnd(seed)));
    
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subPixelJitter;
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    // 2. Camera Ray
    vec4 origin = inverse(ubo.view) * vec4(0, 0, 0, 1);
    vec4 target = inverse(ubo.proj) * vec4(d.x, d.y, 1, 1);
    vec4 direction = inverse(ubo.view) * vec4(normalize(target.xyz / target.w), 0);
    vec3 ray_origin = origin.xyz;
    vec3 ray_dir = normalize(direction.xyz);

    // 3. Trace Path
    vec3 accumulated_color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    payload.seed = seed;
    payload.blue_noise = blue.ba;
    payload.last_bsdf_pdf = 0.0;

    int max_depth = 12;

    for (int depth = 0; depth < max_depth; depth++) { 
        payload.depth = depth;
        traceRayEXT(tlas, gl_RayFlagsNoneEXT, 0xFF, 0, 0, 0, ray_origin, 0.001, ray_dir, 10000.0, 0);
        accumulated_color += payload.color * throughput;

        accumulated_color = min(accumulated_color, vec3(CLAMP_MAX));

        if (payload.hit_flag < 1.5) break; 
        if (depth == 0 && payload.hit_flag > 1.5) {
            max_depth = 8; // Saves 33% rays on diffuse surfaces
        }

        throughput *= payload.weight;
        ray_origin = payload.next_ray_origin;
        ray_dir = payload.next_ray_dir;
        
        float max_throughput = max(max(throughput.r, throughput.g), throughput.b);
        if (max_throughput < 0.001) break;

        // FIX 3: Adaptive Russian Roulette
        // Start checking earlier (Depth 1 or 2).
        // This doesn't reduce quality; it probabilistically terminates paths.
        // Paths that survive get their brightness BOOSTED to compensate (unbiased).
        if(depth >= 4) {
            // Calculate survival probability based on material brightness
            float p = clamp(max_throughput, 0.05, 0.95);
            
            if (rnd(payload.seed) > p) break;
            
            // Boost the survivor so the average brightness remains correct
            throughput /= p;
        }
    }
    
    // 4. FIREFLY CLAMP
    // accumulated_color = min(accumulated_color, vec3(CLAMP_MAX));

    // 5. ACCUMULATION
    vec3 final_color = accumulated_color;

    if (ubo.frameCount > 0) {
        // 1. Load previous frame (Now it is high-precision Linear Float)
        vec3 prev_color = imageLoad(rt_output_image, ivec2(gl_LaunchIDEXT.xy)).rgb;
        
        // 2. Linear Mix
        float blend = 1.0 / float(ubo.frameCount + 1);
        final_color = mix(prev_color, final_color, blend);
    }

    // 3. Store Linear Float (Ready for next frame)
    imageStore(rt_output_image, ivec2(gl_LaunchIDEXT.xy), vec4(final_color, 1.0));
}
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define RAY_TRACING
#include "raytracing.glsl"

layout(set = 0, binding = 1, scalar) buffer readonly SampleBuffer { RaySample samples[]; } sample_buffer;
layout(set = 0, binding = 2, scalar) buffer writeonly OutputHitBuffer { HitData hits[]; } output_buffer;
layout(push_constant) uniform PushConstants { mat4 model; float major_radius; float minor_radius; float height; } pc;
layout(location = 0) rayPayloadEXT RayPayload payload;

const float PI = 3.14159265359;

void main()
{
    uint index = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    if (index >= sample_buffer.samples.length()) return;

    // Torus logic
    vec2 uv = sample_buffer.samples[index].uv;
    float u = uv.x * 2.0 * PI;
    float v = uv.y * 2.0 * PI;
    float R = pc.major_radius; float r = pc.minor_radius; float h = pc.height;
    vec3 local_pos;
    local_pos.x = (R + r * cos(v)) * cos(u);
    local_pos.y = r * sin(v) + h;
    local_pos.z = (R + r * cos(v)) * sin(u);
    vec3 local_normal;
    local_normal.x = cos(v) * cos(u);
    local_normal.y = sin(v);
    local_normal.z = cos(v) * sin(u);
    local_normal = normalize(local_normal);
    vec3 ray_origin = (pc.model * vec4(local_pos, 1.0)).xyz;
    vec3 ray_dir = normalize((pc.model * vec4(local_normal, 0.0)).xyz);
    // Init Seed for RNG
    payload.seed = index + ubo.frameCount * 719393;

    // --- LOOP ---
    vec3 accumulated_color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 primary_hit_pos = vec3(0.0);
    vec3 primary_normal = vec3(0.0);
    float primary_flag = -1.0;

    for (int depth = 0; depth < 8; depth++) { 
        traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, ray_origin, 0.001, ray_dir, 10000.0, 0);

        accumulated_color += payload.color * throughput;

        if (depth == 0) {
            primary_hit_pos = payload.hit_pos;
            primary_flag = payload.hit_flag;
            primary_normal = (payload.hit_flag < 0.0) ? -ray_dir : payload.normal;
        }

        if (payload.hit_flag < 1.5) break; // Stop if Miss (-1) or Stop (1)

        throughput *= payload.weight;
        ray_origin = payload.next_ray_origin;
        ray_dir = payload.next_ray_dir;
        
        if(depth >= 4)
            if (length(throughput) < 0.0001) break;
    }

    vec3 final_color = pow(accumulated_color, vec3(1.0 / 2.2)); // Gamma

    output_buffer.hits[index].hit_pos = primary_hit_pos;
    output_buffer.hits[index].hit_flag = primary_flag;
    output_buffer.hits[index].color = vec4(final_color, 1.0);
    output_buffer.hits[index].normal = primary_normal;
    output_buffer.hits[index].padding = 0.0;
}